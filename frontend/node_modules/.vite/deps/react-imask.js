import {
  IMaskMixin,
  require_prop_types
} from "./chunk-F56MA6UO.js";
import "./chunk-XLOVNOK3.js";
import "./chunk-T7HMXJZQ.js";
import {
  IMask
} from "./chunk-WOK5M35H.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/react-imask/esm/input.js
var import_react = __toESM(require_react(), 1);
var import_prop_types = __toESM(require_prop_types(), 1);
var IMaskInputClass = IMaskMixin((_ref) => {
  let {
    inputRef,
    ...props
  } = _ref;
  return import_react.default.createElement("input", {
    ...props,
    ref: inputRef
  });
});
var IMaskInputFn = (props, ref) => import_react.default.createElement(IMaskInputClass, {
  ...props,
  ref
});
var IMaskInput = import_react.default.forwardRef(IMaskInputFn);

// node_modules/react-imask/esm/hook.js
var import_react2 = __toESM(require_react(), 1);
function useIMask(opts, _temp) {
  let {
    onAccept,
    onComplete,
    ref = (0, import_react2.useRef)(null),
    defaultValue,
    defaultUnmaskedValue,
    defaultTypedValue
  } = _temp === void 0 ? {} : _temp;
  const maskRef = (0, import_react2.useRef)(null);
  const [lastAcceptState, setLastAcceptState] = (0, import_react2.useState)({});
  const [value, setValue] = (0, import_react2.useState)("");
  const [unmaskedValue, setUnmaskedValue] = (0, import_react2.useState)("");
  const [typedValue, setTypedValue] = (0, import_react2.useState)();
  const _destroyMask = (0, import_react2.useCallback)(() => {
    var _maskRef$current;
    (_maskRef$current = maskRef.current) == null || _maskRef$current.destroy();
    maskRef.current = null;
  }, []);
  const storeLastAcceptedValues = (0, import_react2.useCallback)(() => {
    const m = maskRef.current;
    if (!m) return;
    setLastAcceptState({
      value: m.value,
      unmaskedValue: m.unmaskedValue,
      typedValue: m.typedValue
    });
    setTypedValue(m.typedValue);
    setUnmaskedValue(m.unmaskedValue);
    setValue(m.value);
  }, []);
  const _onAccept = (0, import_react2.useCallback)((event) => {
    const m = maskRef.current;
    if (!m) return;
    storeLastAcceptedValues();
    onAccept == null || onAccept(m.value, m, event);
  }, [onAccept]);
  const _onComplete = (0, import_react2.useCallback)((event) => maskRef.current && (onComplete == null ? void 0 : onComplete(maskRef.current.value, maskRef.current, event)), [onComplete]);
  (0, import_react2.useEffect)(() => {
    const {
      value: lastAcceptValue,
      ...state
    } = lastAcceptState;
    const mask = maskRef.current;
    if (!mask || value === void 0) return;
    if (lastAcceptValue !== value) {
      mask.value = value;
      if (mask.value !== value) _onAccept();
    }
    setLastAcceptState(state);
  }, [value]);
  (0, import_react2.useEffect)(() => {
    const {
      unmaskedValue: lastAcceptUnmaskedValue,
      ...state
    } = lastAcceptState;
    const mask = maskRef.current;
    if (!mask || unmaskedValue === void 0) return;
    if (lastAcceptUnmaskedValue !== unmaskedValue) {
      mask.unmaskedValue = unmaskedValue;
      if (mask.unmaskedValue !== unmaskedValue) _onAccept();
    }
    setLastAcceptState(state);
  }, [unmaskedValue]);
  (0, import_react2.useEffect)(() => {
    const {
      typedValue: lastAcceptTypedValue,
      ...state
    } = lastAcceptState;
    const mask = maskRef.current;
    if (!mask || typedValue === void 0) return;
    if (lastAcceptTypedValue !== typedValue) {
      mask.typedValue = typedValue;
      if (!mask.masked.typedValueEquals(typedValue)) _onAccept();
    }
    setLastAcceptState(state);
  }, [typedValue]);
  (0, import_react2.useEffect)(() => {
    const el = ref.current;
    if (!el || !(opts != null && opts.mask)) return _destroyMask();
    const mask = maskRef.current;
    if (!mask) {
      if (el && opts != null && opts.mask) {
        maskRef.current = IMask(el, opts);
        storeLastAcceptedValues();
        if (defaultValue !== void 0) setValue(defaultValue);
        if (defaultUnmaskedValue !== void 0) setUnmaskedValue(defaultUnmaskedValue);
        if (defaultTypedValue !== void 0) setTypedValue(defaultTypedValue);
      }
    } else {
      mask == null || mask.updateOptions(opts);
    }
  }, [opts, _destroyMask, _onAccept]);
  (0, import_react2.useEffect)(() => {
    if (!maskRef.current) return;
    const mask = maskRef.current;
    mask.on("accept", _onAccept);
    mask.on("complete", _onComplete);
    return () => {
      mask.off("accept", _onAccept);
      mask.off("complete", _onComplete);
    };
  }, [_onAccept, _onComplete]);
  (0, import_react2.useEffect)(() => _destroyMask, [_destroyMask]);
  return {
    ref,
    maskRef,
    value,
    setValue,
    unmaskedValue,
    setUnmaskedValue,
    typedValue,
    setTypedValue
  };
}

// node_modules/react-imask/esm/index.js
var import_react3 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());
export {
  IMask,
  IMaskInput,
  IMaskMixin,
  useIMask
};
//# sourceMappingURL=react-imask.js.map
